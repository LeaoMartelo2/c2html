/*
Copyright 2025 LeaoMartelo2 (https://github.com/LeaoMartelo2)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#ifndef C2HTML_H
#define C2HTML_H

#include <assert.h>
#include <stdarg.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#define C2HTML_VERSION "1.1.2"

#define fn static inline
char *__filename;

typedef struct c2html_obj_t {
    const char *filename;
    const char *css_file;
    const char *js_file;
} c2html_obj;

#define C2HTML_OBJ(name, css, js)               \
    c2html_obj name = {#name ".html", css, js}; \
    __filename = strdup(#name ".html");

fn void setup_file(c2html_obj *obj, const char *title, const char *path) {

    char *file_name = strdup(__filename);
    sprintf(__filename, "%s/%s", path, file_name);

    printf("Starting to write to %s\n\n", __filename);

    FILE *file = fopen(__filename, "w");
    assert(file != NULL);

    fprintf(file, "<!--\n");
    fprintf(file, "FILE AUTOMATICALLY GENERATED\n\n");
    fprintf(file, "File is automatically generated by c2html Version %s\n\n", C2HTML_VERSION);
    fprintf(file, "Unless you know what you are doing, any changes made manually will be lost.\n\n");
    fprintf(file, "-->\n");

    fprintf(file, "<!DOCTYPE html>\n");
    /*  fprintf(file, "<html lang=\"pt-BR\">\n");  */
    fprintf(file, "<head>\n");
    fprintf(file, "<meta charset=\"utf-8\" />\n");
    fprintf(file, "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n");

    fprintf(file, "<title>%s</title>\n", title);

    if (obj->css_file) {
        fprintf(file, "<link href=\"%s\" rel=\"stylesheet\">\n", obj->css_file);
    }

    fprintf(file, "</head>\n");
    fprintf(file, "<body>\n");

    fclose(file);
}

fn long c2html_get_file_size(const char *filename) {

    struct stat file_info;

    if (stat(filename, &file_info) != 0) {
        printf("Failed to stat file %s\n", filename);
        exit(1);
    }

    return file_info.st_size;
}

fn void c2html_print_file_size(long size, const char *filename) {

    const char *units[] = {"bytes", "Kb", "Mb", "Gb"};
    double size_units = size;
    int index = 0;

    while (size_units >= 1024 && index < 3) {
        size_units /= 1024;
        index++;
    }

    printf("Written %.2f%s to %s\n\n", size_units, units[index], filename);
}

fn void end_file(c2html_obj *obj) {

    FILE *file = fopen(__filename, "a");
    assert(file != NULL);

    if (obj->js_file) fprintf(file, "<script src=\"%s\" defer></script>", obj->js_file);

    fprintf(file, "\n</body>\n");
    fprintf(file, "</html>\n");

    fclose(file);

    long size = c2html_get_file_size(__filename);
    c2html_print_file_size(size, __filename);
}

fn const char *text_format(const char *text, ...){

#ifndef MAX_TEXTFORMAT_BUFFERS
#define MAX_TEXTFORMAT_BUFFERS 4
#endif

#ifndef MAX_TEXT_BUFFER_LENGHT
#define MAX_TEXT_BUFFER_LENGHT 1024
#endif

    static char buffers[MAX_TEXTFORMAT_BUFFERS][MAX_TEXT_BUFFER_LENGHT];
    static int index;

    char *current_buffer = buffers[index];
    memset(current_buffer, 0, MAX_TEXT_BUFFER_LENGHT);

    va_list args;
    va_start(args, text);
    int required_sz = vsnprintf(current_buffer, MAX_TEXT_BUFFER_LENGHT, text, args);
    va_end(args);

    if(required_sz >= MAX_TEXT_BUFFER_LENGHT){
        printf("Too large of a string to format:\n String passed: %s\n", text);
        exit(1);
    }

    index +=1;

    if(index >= MAX_TEXTFORMAT_BUFFERS) index = 0;

    return  current_buffer;

}

fn void br() {
    FILE *file = fopen(__filename, "a");
    assert(file != NULL);

    fprintf(file, "\n<br>\n");

    fclose(file);
}

fn void br_repeat(int times) {

    for (int i = 0; i < times; ++i) {
        br();
    }
}

fn void script(const char *path) {

    FILE *file = fopen(__filename, "a");
    assert(file != NULL);

    fprintf(file, "\n<script src=\"%s\"></script>\n", path);

    fclose(file);
}

typedef struct {
    bool do_br;
    bool strong;
    bool do_paragraph;
    const char *css_class;

} add_txt_opt;

fn void add_text_opt(const char *text, add_txt_opt opt) {

    FILE *file = fopen(__filename, "a");
    assert(file != NULL);

    if (opt.do_paragraph) {
        fprintf(file, "\n<p");

        if (opt.css_class) fprintf(file, " class=\"%s\"", opt.css_class);

        fprintf(file, "> ");
    }

    if (opt.strong) fprintf(file, "<strong>");

    fprintf(file, "%s", text);
    /*  apparently you dont need to close P tags (?)*/
    // if (opt.do_paragraph) fprintf(file, "</p>");

    if (opt.do_br) fprintf(file, "<br>\n");

    if (opt.strong) fprintf(file, "</strong>");

    fclose(file);
}

#define add_text(text, ...) add_text_opt((text), (add_txt_opt){.do_br = false, .strong = false, .do_paragraph = false, __VA_ARGS__})

fn void h(int sz, const char *text) {

    FILE *file = fopen(__filename, "a");
    assert(file != NULL);

    fprintf(file, "<h%d>%s</h%d>\n", sz, text, sz);

    fclose(file);
}

#define h1(txt) h(1, txt)
#define h2(txt) h(2, txt)
#define h3(txt) h(3, txt)


typedef struct {
    char *css_class;
    bool close;
    bool in_line;
    char *in_line_text;
    char *id;
} cstm_tag_opt;

fn void custom_tag_opt(const char *tag, cstm_tag_opt opt) {

    FILE *file = fopen(__filename, "a");
    assert(file != NULL);

    if (opt.in_line_text) opt.in_line = true;

    if (opt.close) goto close;

    if (tag) {
        fprintf(file, "<%s", tag);

        if (opt.css_class) {
            fprintf(file, " class=\"%s\"", opt.css_class);
        }

        if (opt.id) {
            fprintf(file, " id=\"%s\"", opt.id);
        }

        fprintf(file, ">");

        if (opt.in_line) {
            if (opt.in_line_text) fprintf(file, "%s", opt.in_line_text);

            goto close;
        }

        goto at_exit;
    }

at_exit:
    fclose(file);
    return;

close:
    if (tag) {
        fprintf(file, "</%s>", tag);
    }

    fclose(file);
    return;
}

#define custom_tag(x, ...) custom_tag_opt((x), (cstm_tag_opt){.close = false, __VA_ARGS__})

typedef struct {
    const char *href;
    const char *css_class;
} addlink_opt;

fn void add_link_opt(const char *text, addlink_opt opt) {

    FILE *file = fopen(__filename, "a");
    assert(file != NULL);

    fprintf(file, "<a");

    if (opt.href) fprintf(file, " href=\"%s\"", opt.href);
    if (opt.css_class) fprintf(file, " class=\"%s\"", opt.css_class);

    fprintf(file, ">");
    fprintf(file, "%s", text);
    fprintf(file, "</a>");

    fclose(file);
}

#define add_link(x, ...) add_link_opt((x), (addlink_opt){__VA_ARGS__})

typedef struct {
    char *width;
    char *css_class;
} addimg_opt;

fn void add_image_opt(const char *img, addimg_opt opt) {

    FILE *file = fopen(__filename, "a");
    assert(file != NULL);

    fprintf(file, "\n<img src=");

    if (img) fprintf(file, "\"%s\"", img);

    if (opt.css_class) fprintf(file, " class=\"%s\"", opt.css_class);

    if (opt.width) fprintf(file, " width=%s", opt.width);

    fprintf(file, " >\n");

    fclose(file);
}

#define add_img(x, ...) add_image_opt((x), (addimg_opt){__VA_ARGS__})

typedef struct {
    const char *css_class;
} _span_opt;

fn void span_opt(const char *text, _span_opt opt) {

    FILE *file = fopen(__filename, "a");
    assert(file != NULL);

    fprintf(file, "<span");

    if (opt.css_class) fprintf(file, " class=\"%s\"", opt.css_class);

    fprintf(file, ">");
    fprintf(file, "%s", text);
    fprintf(file, "</span>");

    fclose(file);
}

#define span(x, ...) span_opt((x), (_span_opt){__VA_ARGS__})

typedef struct {
    char *id;
    char *css_class;
    bool dont_close;
} button_options;

fn void button_opt(const char *text, button_options opt) {

    FILE *file = fopen(__filename, "a");
    assert(file != NULL);

    fprintf(file, "<button");
    if (opt.id) fprintf(file, " id=\"%s\"", opt.id);
    if (opt.css_class) fprintf(file, " class=\"%s\"", opt.css_class);
    fprintf(file, ">");
    fprintf(file, "%s", text);
    if (opt.dont_close) goto at_exit;
    fprintf(file, "</button>");

at_exit:
    fclose(file);
    return;
}

#define button(x, ...) button_opt((x), (button_options){.dont_close = false, __VA_ARGS__})

typedef struct {
    char *id;
    char *type;
    char *width;
    char *height;
} video_options;

fn void add_video_opt(const char *src, video_options opt) {

    FILE *file = fopen(__filename, "a");
    assert(file != NULL);

    fprintf(file, "<video controls src=\"%s\"", src);

    if (opt.id) fprintf(file, " id=\"%s\"", opt.id);

    if (opt.type) fprintf(file, " type=\"%s\"", opt.type);

    if (opt.width) fprintf(file, " width = \"%s\"", opt.width);

    if (opt.height) fprintf(file, " height = \"%s\"", opt.height);

    fprintf(file, "></video>");

    fclose(file);
}

#define add_video(x, ...) add_video_opt((x), (video_options){__VA_ARGS__})

#endif /* ! C2HTML_H */
